# Многопользовательская авторизация/Keycloak Multi-Tenancy на SPI Keycloak orgs от Phase two.


**Мультитенантность** (англ. multitenancy — множественная аренда) — **элемент архитектуры программного обеспечения, где единый экземпляр приложения обслуживает множество организаций-клиентов («арендаторов»)**

Keycloak из коробки (vanila KC) предоставляет полную изоляцию тенантов друг от друга. Полностью исключая любое, даже преднамеренное воздействие на другой тенант. Каждый тенант имеет доступ только к собственным данным, пользователям, настройкам и т.д. Поэтому для реализации multi-tenancy необходимо кастомизировать функционал Keycloak. 

Keycloak известен, как сервис управления аутентификацией и доступами, функционал которого легко можно расширять с помощью плагинов SPI. Кастомизация интерфейсов поставщиков услуг (SPI) подробно описана и легко реализуема. 
Использование плагинов позволяет Keycloak расширять основные протоколы аутентификации и авторизации по желанию разработчиков. Добавлять необходимый функционал в соответствии с бизнес требованиями.

![[img_1.png]]

## Варианты  реализации multi-tenancy в Keycloak.

На текущий момент Keycloak не предоставляет возможность реализации multi-tenancy из коробки. 
Создание и использование пользовательских аутентификаторов, мапперов протоколов, REST-ресурсов, JPA-сущностей, провайдеров моделей и т. д. для каждого тенанта производится в рамках одного пространства - Realm. Realm  - изолированные пространства в Keycloak. Между ними нет общих клиентов или поставщиков персональных данных. Пользователь/администратор из одного пространства не может получить информацию о пользователях из другого пространства. 

Чтобы реализовать функционал multi-tenancy, можем использовать три варианта:
### 1 Realm - N tenant.
*Объединение всех клиентов, пользователей и настроек в одной области.*

Объединить всех поставщиков персональных данных, клиентов, и пр. в одном Realm. И использовать управление пользователями на уровне ролей в рамках одного Realm. 
Для этого подходит можно использовать реализацию групп пользователей (Group KC). Определив для каждого тенанта отдельную группу, добавив соответсвующие роли, и  отдельного клиента. Однако на данный момент в релизной версии Keycloak нет достаточных прав администратора, представляющих детализированный контроль группой или группами пользователей. Поэтому по мере увеличения ролей в каждой организации будет будет увеличиваться сложность поддержки такого сервиса.


### 1 Realm - 1 Tenant.
*Создание отдельной области для каждого тенанта.*

В этом случае нужно настроить каждого клиента или нескольких клиентов в каждом Realm. И каждый клиент должен уметь обрабатывать всех поставщиков персональных данных и всех URI от каждого Realm. При добавлении нового тенанта нужно добавлять новый Realm и на лету нужно добавлять информацию о нем в каждый клиент. 
Здесь есть ограничение на масштабируемость, разные пользователи сообщают от максимальном количестве не превышающем ~300~400 Realms. Так же такой подход усложняет управление настройками доступа для каждого тенанта. 

### N tenant-reams - 1 app realm
*Создание общей области для приложений и клиентов.*

Для каждого тенанта создается отдельный Realm (tenant-realm). И отдельно создается Realm для приложения(app-realm). App-realm является прокси для идентификации тенантов. Все приложения используют клиенты app-realm. Пользовать проходит аутентификацию в tenant-realm, затем переправляется в app-realm. Это позволяет администраторам тенанта управлять только своими пользователями. 
В этом случае будет наблюдаться дублирование ресурсов. В tenant-realm пользователь проходит аутентификацию, ему создается контекст и это контекст будет продублирован в app-realm. Создаются две пользовательские сессии. Аллоцируется x2 памяти и дублируются данные в обоих хранилищах в tenant-realm и app-realm. 


## SPI Keycloak-orgs

В этом статье рассмотрим SPI от команды Phase Two - keycloak-orgs. Предлагаемое  решение реализует подход 1 Realm - N tenant. 
SPI Расширяет основной сервер Keycloak сущностями, моделирующими организации (тенантов) и связанные с ними пользователи, роли и поставщики идентификационных данных. Это отличный пример, как использовать архитектуру плагинов Keycloak для решения задач, не решаемых его основной функциональностью.

Особенности реализации SPI Keycloak-orgs :
- Организация (tenant) является объектом верхнего уровня. Пользователь может быть членом разных организаций. 
- Делегируется  управление организацией: управление сотрудниками, приглашения, управления ролями и авторизацией.
- Весь функционал доступен по Rest API
- Расширение Keycloak UI 

## Рабочий процесс

Наши следующие шаги:
1. Развернем тестовое окружение Keycloak с плагином SPI.
2. Добавим пользователя и организацию.
6. Добавим мапперы к клиенту и рассмотрим атрибуты(claims), которые будут добавлены в токен доступа. 
7. Рассмотрим портал организатора.
8. Рассмотрим, какие ограничения есть у данного плагина.

#### Тестовое окружение

Для разворачивания воспользуемся файлом `docker-compose` :

> TODO docker-compose -> gist
> добавить описание, что разворачиваем и зачем

> под кат при оформлении статьи

```docker-compose
version: "3.9"

volumes:
  config_data:
    driver: local
    driver_opts:
      type: none
      device: config/
      o: bind
  postgres_data:
    driver: local

services:
#  init-config:
#    build:
#      context: ./docker
#      dockerfile: Dockerfile.init
#    volumes:
#      - type: bind
#        source: config/
#        target: /opt/

  postgres:
    image: postgres:${KC_POSTGRES_IMAGE_TAG:-11}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    container_name: ${POSTGRES_CONTAINER_NAME:-postgres}
    ports:
      - ${KC_POSTGRES_PORT_MAPPING:-5432}:5432
    restart: on-failure
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: password
    healthcheck:
      test: pg_isready -d $${POSTGRES_DB} -U $${POSTGRES_USER}
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    deploy:
      resources:
        limits:
          memory: 256M

  keycloak:
    image: quay.io/phasetwo/phasetwo-keycloak:24.0.3
    container_name: keycloak
    entrypoint: [ "/opt/keycloak/bin/kc.sh", "start", "--spi-email-template-provider=freemarker-plus-mustache", "--spi-email-template-freemarker-plus-mustache-enabled=true", "--spi-theme-cache-themes=false" ]
    volumes:
      - config_data:/opt/keycloak/conf
    environment:
      #      PROXY_ADDRESS_FORWARDING: 'true'
      KEYCLOAK_USER: admin
      KEYCLOAK_PASSWORD: password
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: password
      KC_DB_URL_HOST: postgres
      KC_DB_URL_DATABASE: keycloak
      KC_DB_SCHEMA: public
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: password
      KC_HOSTNAME_STRICT: 'false'
      KC_HTTP_ENABLED: 'true'
      KC_PROXY: 'edge'
      KC_LOG_LEVEL: INFO
      KC_FEATURES: preview
    ports:
      - 80:8080
      - 443:8443
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/realms/master"]
      start_period: 10s
      interval: 30s
      retries: 3
      timeout: 5s
```

#### Добавим организацию.

Чтобы добавить организацию, выберем в меню слева пункт **Organizations** . Нажмем на кнопку **Create organization**. Заполним поле `name` уникальный идентификатор орагнизации. Здесь важно не использовать специальные символы. Например вместо `-` лучше использовать `_`. В поле `Display name` введем настоящее название орагнизации. Это упростит в дальнейшем работу. Добавим в поле `Domains` один или несколько доменов, которые будут использоваться в клиентах для соотношения пользователей к конкретной организации. 

![[CleanShot 2024-05-23 at 20.22.05.png]]
После этого Keycloak создаст сервисного пользователя с правами администратора для данной организации. У разработчиков SPI не было возможности скрыть этого пользователя, как это делает Keycloak.

![[CleanShot 2024-05-24 at 10.03.14.png]]

В разделе **Organizations**, появится наша организация. Объект в котором мы можем добавлять атрибуты, участников, приглашения, роли, провайдеров идентификационных данных. 

![[CleanShot 2024-05-24 at 10.10.20.png]]

Теперь добавим пользователя в нашу организацию. Выберем пункт **Users** в меню слева. 
Нажмем на кнопку **Add user**. И заполним информацию о пользователе :
![[CleanShot 2024-05-24 at 10.15.04.png]]
Нажмем **Save**.
Теперь вернемся в нашу организацию. На вкладке **Members** нажмем **Add member**. В открывшемся окне выберем пользователя **demouser** и нажмем **Add**.
![[CleanShot 2024-05-27 at 09.12.26.png]]
Теперь в списке пользователей организации появится созданный нами пользователь.

Создадим роль собственную роль внутри организации. Перейдем на вкладку **Roles** и нажмем кнопку **Create Role**.  Создадим роль `demo_role`.
![[CleanShot 2024-05-27 at 09.23.28.png]]

Теперь добавим роли нашему пользователю. Перейдем на вкладку **Members**. Нажмем на три точки справа от имени пользователя, затем **Assign role**, чтобы роли внутри организации. Откроется список ролей организации:
![[CleanShot 2024-05-27 at 09.25.25.png]]
Выберем роли и добавляем их пользователю нажав на кнопку **Save**.

## Добавление мапперов клиенту

На панели слева выберем **Clients**. Затем выберем клиента, которому будем добавлять мапперы. В нашем случае *demo_client*. Перейдем на вкладку **Client scopes**. В списке выберем скоуп с названием *demo_client-dedicated*. Нажмем на кнопку **Add mapper**. В раскрывшемся списке выберем **By configuration**.
![[CleanShot 2024-05-27 at 15.01.15.png]]

Откроется список мапперов, которые мы можем добавить. Здесь выберем **Active organization**, **Organization Attribute**, **Organization Role**.
![[CleanShot 2024-05-27 at 15.03.40.png]]

Этим действием добавим в токен доступа дополнительные атрибуты (claims):
- *organization-attribute* - отображает атрибуты организации в атрибутах токена. 
- *active-organization* - отображает свойства активной организации в атрибутах токена.
- *organization-role* - отображает роли пользователя для каждой организации

## Получение токена доступа и его атрибутов

Получим токен доступа и рассмотрим атрибуты payload. 
Для это выполним:
```shell
curl -X "POST" "https://bezeq.ru/realms/demo/protocol/openid-connect/token" \
     -H 'Content-Type: application/x-www-form-urlencoded; charset=utf-8' \
     --data-urlencode "client_id=demo_client" \
     --data-urlencode "client_secret=D0BjK57T4ZpbMMv9tIu34QPg8yxcbd8t" \
     --data-urlencode "grant_type=password" \
     --data-urlencode "password=password" \
     --data-urlencode "scope=openid" \
     --data-urlencode "username=user@demo.org" \
     | jq -r .access_token | cut -d . -f 2 | base64 --decode | sed -ne 's/$/ } &/p' | jq -r .
```

В результате получим список атрибутов. Нас интересуют следующие : 
```json
{
  ...,
  "organization-attribute": {
    "a60e3949-83c6-4e1c-9aaa-75991468e00b": {
      "name": "demo_organization",
      "attributes": {
        "product": [
          "product_name"
        ]
      }
    }
  },
  ...,
  "active-organization": {
    "role": [
      "view-organization",
      "view-members",
      "view-roles",
      "demo-organization-role"
    ],
    "name": "demo_organization",
    "id": "a60e3949-83c6-4e1c-9aaa-75991468e00b",
    "attribute": {
      "product": [
        "product_name"
      ]
    }
  },
  "organization-role": {
    "a60e3949-83c6-4e1c-9aaa-75991468e00b": {
      "roles": [
        "view-organization",
        "view-members",
        "view-roles",
        "demo-organization-role"
      ],
      "name": "demo_organization"
    }
  },
  ...
}
```

### Атрибуты организаций

Пользователь может состоять в нескольких организациях. В токене доступа содержатся сведения о всех этих организациях. Информация представлена в виде *KV* коллекции *organization-attribute*. Ключ определяется уникальным идентификатором каждой организации. 

Информация об организации:
- name - название организации
- attributes - список атрибутов организации, например продуктов или сфер деятельности 

Сейчас здесь только одна организация которую мы добавили. 

### Атрибуты активной организации

Если пользователь состоит в нескольких организациях, то при аутентификации ему будет предложено выбрать, какую организацию считать активной. Чтобы сменить активную организацию, потребуется заново аутентифицировать пользователя и получить новый токен авторизации.

Информация об активной организации в объекте *active-organization* :
 - *role* - список в котором перечисляются роли пользователя в активной организации
 - *name* - название организации 
 - *id* - уникальный идентификатор организации
 - *attribute* - список атрибутов активной организации, например продуктов или сфер деятельности 

Сейчас здесь будут те роли, которые мы назначили пользователю ранее.

### Список ролей для всех организаций в которых состоит пользователь

Список ролей пользователя для всех организаций в которых он состоит перечислен в *KV* коллекции *organization-role*, где ключом списка является уникальный идентификатор организации. 

Информация о ролях:
- *name* - название организации 
- *roles* - список ролей пользователя в данной организации 

## Портал организатора

Портал - отдельное веб-приложение. Каждый пользователь организации может попасть туда используя собственные учетные данные (credentials). 


Чтобы попасть в портал выберем в левом боковом меню **Clients**. В открывшемся списке перейдем по ссылке напротив клиента *admin-portal* 
![[CleanShot 2024-05-27 at 16.28.06.png]]

Открывшуюся форму заполним учетными данными пользователя. Нажмем **Sign In** и попадем в портал организаций.
```json
u : demouser
p : password
```
![[CleanShot 2024-05-27 at 16.28.59.png]]

После успешной авторизации 

Здесь представлены все организации в которых состоит наш пользователь. 
![[CleanShot 2024-05-27 at 16.31.56.png]]
Интерфейс интуитивно понятен, не предоставляет большой сложности.
Перейдем в **Demo organization**.  
Здесь пользователь может совершать действия в соответствии с теми ролями, которые мы ему назначили.
![[CleanShot 2024-05-27 at 16.35.39 1.png]]
У текущего пользователя 3 роли:
- view-organization - роль предоставляет просмотр сведений об организации 
- view-members - роль предоставляет просмотр сведений о пользователях
- view-roles - роль предоставляет просмотр сведений о ролях пользователей
Таким образом экран организации для пользователя *demouser* будет таким:
![[CleanShot 2024-05-27 at 16.39.44.png]]
Все действия, которые не 